#-*-org-*-

* Questions

**** Opener

- Let's go around in order and introduce ourselves. Please state your
  name, your role in the development of Erlang, and whether you're a
  dog person, cat person, or a ferrot person.


** Prehistory

**** Lessons learned from AXE

- When you started Erlang in 1985, you had some pretty specific
  targets to go after in PLEX. E.g. handling a very large number of
  concurrent activities, soft real time performance, distribution,
  continuous operations, and so on.

  This question may be to Bjarne and Mike, but anyone feel free to
  contribute - what were some fundamental lessons learned from AKE -
  this is the precursor of AXE/PLEX - that were codified in the
  Ericsson engineering mindset in 1985.

  E.g. one observation in Joe's history of Erlang was "The design of
  AXE and PLEX used a mixture of hardware protection and data copying
  that eliminated the use of pointers and corrected many of the errors
  in the AKE."

**** Prior experiences that influenced research into Erlang

- Bjarne you had some foramtive experience earlier with Lisp. Ericsson
  had seen great improvements in AXE over AKE. Joe was a physicist and
  had experience with rockets. What are some of the ideas or
  influences that weighed heavily as you set out to find a language to
  improve on PLEX?

** Research and development

**** JAM

- Joe, Chuck Moore, creator of Forth, said that "compilers are
  probably the worst code ever written. They are written by someone
  who has never written a compiler before and will never do so again."
  Yet, the design of your original abstract machine, the JAM, survives
  in large part as the BEAM today. How the hell did you do that?

  - What advice would you have for programmers who might not think
    they have it in them to create something new?

**** Solving Ericsson's software problem

- Bjarne, in Joe's history of Erlang, he says you told him to "solve
  Ericsson's software problem" - two parts to my question, 1) did you
  hedge by telling the same thing to the OO and imperative teams, or
  did you already know the rules based camp would win and 2) when did
  you start to realize that he might actually be pulling it off?

**** A type system

- Why did Philip Wadler's attempt to turn Erlang into ML fail
  completely?

  - How does know why this didn't work impact your desire to use say
    Haskell or ML on a project?

**** Features that never made it

- Joe, Mike, and Robert, in the history of Erlang you experimented
  with new features and users didn't like it, you pulled it. Were
  there any features that any of really really liked, but didn't make
  it into Erlang because some /user/?

**** Virdings first rule of programming

- Robert, are you familiar with this "Virding's first rule of
  programming?"

  : Any sufficiently complicated concurrent program in
  : another language contains an ad hoc informally-specified bug-ridden
  : slow implementation of half of Erlang.

  Seriously, what's so hard about "concurrency"?


** Erlang in the wild

*** Erlang's exodus

**** Jane's first impression

- Jane, when you first encountered Erlang - and this could be the
  language, a train set, Joe, Robert, or Mike - what was that and what
  were you first impressions?

**** Difficulty of selling Erlang

- Jane you bring a perspective that is hard to come by in Erlang
  developer circles as you have interface with those who are seeing
  this technology for the first time and being asked to make some very
  important strategic decisions in possibly adopting it as a core
  technology. What's been the most challenging part of those
  discussions?


*** Adoption

**** Mission accomplished?

- Here's a short list of some companies - you may have heard of some:
  IBM, VISA, Facebook, BT Mobile, Pivotal, WhatsApp - and a telecom
  startup called Ericsson. Each company uses Erlang in variying
  degrees - for some it's a small line of business, for others it's
  core to their business.

  Let me now read off the ten requirements that were outlined going
  into Erlang's research and development. As I read these, I want
  everyone to imagine how each of these requirements potentially fits
  into products they work on or know of.

  1. Handling a very large number of concurrent activities

  2. Actions to be performed at a certain point of time or within a
     certain time

  3. Systems distributed over several computers

  4. Interaction with hardware

  5. Very large software systems

  6. Complex functionality such as feature interaction

  7. Continuous operation over several years

  8. Software maintenance (reconfiguration, etc.) without stopping the
     system

  9. Stringent quality and reliability requirements

  10. Fault tolerance both to hardware failures and software errors

  Super softball question. After 30 years now, looking at how Erlang
  is used, inside Ericsson and outside, are you all comfortable saying
  "missing accopmlished?"

**** Elixir

- Elixir... This is a new language, similar to Erlang semantically but
  with some novel innovations like macros and function piping. Apart
  from it's kinder and gentler syntax - so some say - people are
  attracted to Elixir's now outstanding toolchain and documentation:

  Mix for building, Distillery for deployment, ExUnit for testing,
  getting started guides that focus on developer understanding and
  productivity, extensive language documentation, and a web framework
  that - dare I say it - sort of reminds programmers of a very popular
  web framework for Ruby.

  Driving this community is a small, distributed, ad hocly financed
  team of very talented enthusiasts.

  What can we learn about the effectiveness of community there - and
  how could elements of that model be applied to Erlang's development,
  which is still largely driven by a single organization.

**** The only people in the world concerned with software failure

- Joe, Robert and Mike, in 1989 at the SETSS conference you trolled
  people relentlessly by asking the same question, "what happens if it
  fails?" The answer was "we assume it won't". After this you realized
  that you were the only people in the world designing systems that
  could recover from software failures.

  Even today, systems are built to guard against hardware failures.

  This seems to me the dividing line between Erlang and everything
  else, even today.

  My question is this, why hasn't this idea caught on?


** The future

**** What in Erlang needs revision?

- What sacrifice did you end up making in the system design that you'd
  like to either go back in time and reverse or conceded that it was
  still the right decision, but you'd like to fix something?

**** Legitimate alternatives

- Let's assume for a moment, just for argument sake, that Erlang has
  been banned from polite society, for whatever reason -- it's syntax
  is horrible, you can't easily reorder lines, it hates state,
  etc. etc. -- in all seriousness, imagine it -- what would you
  recommend someone use who should otherwise use Erlang, if it wasn't
  banned from polite society?

**** Advice to learners

- Advice for a new programmer who wants to work on actual hard
  problems and be excellent at it.
